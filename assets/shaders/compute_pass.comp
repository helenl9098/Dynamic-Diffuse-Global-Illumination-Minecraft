#version 450
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_scalar_block_layout : require

#define PI 3.1415926535897932384626433832795
#define RAY_MIN_DIST 0.01
#define EPSILON 0.005
#define MARCH_ITER 32
#define MARCH_EPS 0.1
#define INF 1.0/0.0

#include "structs.glsl"

layout(local_size_x = 16, local_size_y = 16) in;
layout(binding = 0) uniform RenderSettings
{
    int screen_width;
    int screen_height;
    int max_bounces;
    int camera_mode;
    int render_mode;
    int scene;
    bool visualize_probes;
}
render_settings;

layout(binding = 1, rgba8) uniform writeonly image2D result_image;
layout(binding = 2) buffer Random { float random_source[]; };
layout(binding = 3) uniform Camera
{
    mat4 matrix;
    vec4 params; /* aspect, hfov, scale, 0 */
}
cam;
ivec2 dim = imageSize(result_image);
uint iframe = 1;

layout(std430, binding = 4) buffer Spheres { Sphere spheres[]; };
layout(std430, binding = 5) buffer Materials { Material materials[]; };

layout(binding = 6, rgba8) uniform readonly image2D probe_image_albedo;
layout(binding = 7, rgba8) uniform readonly image2D probe_image_distances;

layout(binding = 8) uniform IrradianceField
{
    ivec3 probe_count;
    int side_length;
    float hysteresis;
    int sqrt_rays_per_probe;
    vec3 field_origin;
} irradiance_field;

layout(binding = 9, rgba8) uniform readonly image2D block_texture;

#include "util.glsl"
#include "camera.glsl"
#include "samples_mapping.glsl"
#include "intersection.glsl"
#include "distance_functions.glsl"
#include "material.glsl"
#include "integrators.glsl"

bool colour(inout Ray ray, inout Record record)
{
    record.distance = -1;
    bool intersected = intersect_spheres(ray, record);

    if (intersected)
    {
        apply_record(ray, record);
        return true;
    }
    else
    {
        record.albedo = vec3(0);
//        record.emission = mix(vec3(0.9, 0.9, 1), vec3(.6, 0.6, 1), (ray.direction.y - 0.5) * 2);
        record.emission = vec3(0);
        record.reflectiveness = 0.0;
        return false;
    }
}

vec3 trace(in Ray ray)
{
    vec3 throughput = vec3(1);
    vec3 final = vec3(0);

    Record record;
    for (int i = 0; i < render_settings.max_bounces; i++)
    {
        if (!colour(ray, record))
        {
            final += throughput * record.emission;
            break;
        }
        final += throughput * record.emission;
        throughput *= record.albedo * record.reflectiveness;
    }

    return final;
}

vec3 eval_integrator

	(int integrator_idx,
	 Ray ray)
	
{
	switch (integrator_idx)
	{
	case 0:
		return integrator_DDGI(ray, 0, INF, irradiance_field.probe_count,
                                            irradiance_field.side_length,
                                            irradiance_field.field_origin);
    case 1:
		return integrator_direct(ray, 0, INF);
	case 2:
		return integrator_indirect(ray, 0, INF, irradiance_field.probe_count,
                                                irradiance_field.side_length,
                                                irradiance_field.field_origin);
	case 3:
		return integrator_color(ray, 0, INF);
    case 4:
        return integrator_normal(ray, 0, INF);
	case 5:
		return integrator_depth(ray, 0, INF);
    default:
        return integrator_DDGI(ray, 0, INF, irradiance_field.probe_count,
                                            irradiance_field.side_length,
                                            irradiance_field.field_origin);
	}
}


Ray get_camera_ray

	(int   camera_idx,
	 float u,
	 float v)
	 
{
	switch (camera_idx)
	{
	case 0:
		return camera_pinhole_ray(u, v);
	case 1:
		return camera_ortho_ray(u, v);
	default:
		return camera_spherical_ray(u, v);
	}
}

ivec2 get_texture_coords_of_probe_index(int index) {
    int y_probe = index / (irradiance_field.probe_count.x * irradiance_field.probe_count.z);
    int x_probe = index - (y_probe * irradiance_field.probe_count.x * irradiance_field.probe_count.z);

    return ivec2(x_probe, y_probe) * irradiance_field.sqrt_rays_per_probe;
}

// DEBUGGING: use this if you want to display the entire probe texture
ivec2 get_probe_image_coords(vec2 original) {
    int probe_texture_width  = irradiance_field.probe_count.x * irradiance_field.probe_count.z
                                * irradiance_field.sqrt_rays_per_probe;
    int probe_texture_height = irradiance_field.probe_count.y
                                * irradiance_field.sqrt_rays_per_probe;

    return ivec2(int(original.x * probe_texture_width / render_settings.screen_width),
                 int(original.y * probe_texture_height / render_settings.screen_height));
}

void main()
{
	/* 
		Integrators enumeration:
		
		0: DDGI
        1: direct lighting
		2: indirect lighting
		3: color
		4: normal
        5: depth
	*/

    int integrator_idx = render_settings.render_mode;

    vec3 sampled = vec3(0);
    vec2 coord = vec2(gl_GlobalInvocationID.xy) / dim; 
	coord.y = 1.0-coord.y; /* flip image vertically */
        
	Ray ray = get_camera_ray(render_settings.camera_mode, coord.x, coord.y);
	sampled += eval_integrator(integrator_idx, ray);

    ivec2 coords = get_probe_image_coords(gl_GlobalInvocationID.xy);

    vec3 probe = imageLoad(probe_image_albedo, coords).xyz;

    // LOOK: change "sampled" to "probe" for result_image if you want to see the texture.
    imageStore(result_image, ivec2(gl_GlobalInvocationID.xy), vec4(sampled, 0));
}
